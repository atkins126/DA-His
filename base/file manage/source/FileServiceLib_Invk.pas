unit FileServiceLib_Invk;

// ----------------------------------------------------------------------
//  This file was automatically generated by Remoting SDK from a
//  RODL file downloaded from a server or associated with this project.
//
//  Do not modify this file manually, or your changes will be lost when
//  it is regenerated the next time you update your RODL.
// ----------------------------------------------------------------------

{$I RemObjects.inc}

interface

uses
  {$IFDEF DELPHIXE2UP}System.SysUtils{$ELSE}SysUtils{$ENDIF},
  {$IFDEF DELPHIXE2UP}System.Classes{$ELSE}Classes{$ENDIF},
  uROEncoding,
  uROXMLIntf,
  uROServer,
  uROServerIntf,
  uROClasses,
  uROTypes,
  uROClientIntf,
  FileServiceLib_Intf;

type
  { Forward declarations }
  TFileService_Invoker = class;

  TFileService_Invoker = class(TROInvoker)
  public
    constructor Create; override;
  published
    procedure Invoke_FindPath(const __Instance: IInterface; const __Message: IROMessage; const __Transport: IROTransport; out __oResponseOptions: TROResponseOptions);
    procedure Invoke_FileAttr(const __Instance: IInterface; const __Message: IROMessage; const __Transport: IROTransport; out __oResponseOptions: TROResponseOptions);
    procedure Invoke_UploadFile(const __Instance: IInterface; const __Message: IROMessage; const __Transport: IROTransport; out __oResponseOptions: TROResponseOptions);
    procedure Invoke_DownloadFile(const __Instance: IInterface; const __Message: IROMessage; const __Transport: IROTransport; out __oResponseOptions: TROResponseOptions);
    procedure Invoke_RenameFile(const __Instance: IInterface; const __Message: IROMessage; const __Transport: IROTransport; out __oResponseOptions: TROResponseOptions);
    procedure Invoke_RemoveFile(const __Instance: IInterface; const __Message: IROMessage; const __Transport: IROTransport; out __oResponseOptions: TROResponseOptions);
    procedure Invoke_ServiceValue(const __Instance: IInterface; const __Message: IROMessage; const __Transport: IROTransport; out __oResponseOptions: TROResponseOptions);
  end;

implementation

uses
  uROEventRepository,
  uRORes,
  uROClient;

constructor TFileService_Invoker.Create;
begin
  inherited Create();
  FAbstract := false;
end;

procedure TFileService_Invoker.Invoke_FindPath(const __Instance: IInterface; const __Message: IROMessage; const __Transport: IROTransport; out __oResponseOptions: TROResponseOptions);
var
  l_Path: string;
  lResult: FileServiceLib_Intf.FileArray;
  __lObjectDisposer: TROObjectDisposer;
  __lintf: FileServiceLib_Intf.IFileService;
begin
  CheckRoles(__Instance, GetDefaultServiceRoles());
  lResult := nil;
  try
    if not Supports(__Instance, IFileService, __lintf) then begin
      raise EIntfCastError.Create('Critical error in TFileService_Invoker.Invoke_FindPath: __Instance does not support FileService interface');
    end;

    __Message.Read('Path', System.TypeInfo(string), l_Path, [paAsUTF8String]);

    lResult := __lintf.FindPath(l_Path);

    __Message.InitializeResponseMessage(__Transport, 'FileServiceLib', 'FileService', 'FindPathResponse');
    __Message.Write('Result', System.TypeInfo(FileServiceLib_Intf.FileArray), lResult, []);
    __Message.Finalize();
    __Message.UnsetAttributes(__Transport);

  finally
    __lintf := nil;
    __lObjectDisposer := TROObjectDisposer.Create(__Instance);
    try
      __lObjectDisposer.Add(lResult);
    finally
      __lObjectDisposer.Free();
    end;
  end;
end;

procedure TFileService_Invoker.Invoke_FileAttr(const __Instance: IInterface; const __Message: IROMessage; const __Transport: IROTransport; out __oResponseOptions: TROResponseOptions);
var
  l_FileName: string;
  lResult: FileServiceLib_Intf.FileInfo;
  __lObjectDisposer: TROObjectDisposer;
  __lintf: FileServiceLib_Intf.IFileService;
begin
  CheckRoles(__Instance, GetDefaultServiceRoles());
  lResult := nil;
  try
    if not Supports(__Instance, IFileService, __lintf) then begin
      raise EIntfCastError.Create('Critical error in TFileService_Invoker.Invoke_FileAttr: __Instance does not support FileService interface');
    end;

    __Message.Read('FileName', System.TypeInfo(string), l_FileName, [paAsUTF8String]);

    lResult := __lintf.FileAttr(l_FileName);

    __Message.InitializeResponseMessage(__Transport, 'FileServiceLib', 'FileService', 'FileAttrResponse');
    __Message.Write('Result', System.TypeInfo(FileServiceLib_Intf.FileInfo), lResult, []);
    __Message.Finalize();
    __Message.UnsetAttributes(__Transport);

  finally
    __lintf := nil;
    __lObjectDisposer := TROObjectDisposer.Create(__Instance);
    try
      __lObjectDisposer.Add(lResult);
    finally
      __lObjectDisposer.Free();
    end;
  end;
end;

procedure TFileService_Invoker.Invoke_UploadFile(const __Instance: IInterface; const __Message: IROMessage; const __Transport: IROTransport; out __oResponseOptions: TROResponseOptions);
var
  l_FileName: string;
  l_FileSize: Integer;
  l_StartPos: Integer;
  l_Block: Binary;
  lResult: Integer;
  __lObjectDisposer: TROObjectDisposer;
  __lintf: FileServiceLib_Intf.IFileService;
begin
  CheckRoles(__Instance, GetDefaultServiceRoles());
  l_Block := nil;
  try
    if not Supports(__Instance, IFileService, __lintf) then begin
      raise EIntfCastError.Create('Critical error in TFileService_Invoker.Invoke_UploadFile: __Instance does not support FileService interface');
    end;

    __Message.Read('FileName', System.TypeInfo(string), l_FileName, [paAsUTF8String]);
    __Message.Read('FileSize', System.TypeInfo(Integer), l_FileSize, []);
    __Message.Read('StartPos', System.TypeInfo(Integer), l_StartPos, []);
    __Message.Read('Block', System.TypeInfo(Binary), l_Block, []);

    lResult := __lintf.UploadFile(l_FileName, l_FileSize, l_StartPos, l_Block);

    __Message.InitializeResponseMessage(__Transport, 'FileServiceLib', 'FileService', 'UploadFileResponse');
    __Message.Write('Result', System.TypeInfo(Integer), lResult, []);
    __Message.Finalize();
    __Message.UnsetAttributes(__Transport);

  finally
    __lintf := nil;
    __lObjectDisposer := TROObjectDisposer.Create(__Instance);
    try
      __lObjectDisposer.Add(l_Block);
    finally
      __lObjectDisposer.Free();
    end;
  end;
end;

procedure TFileService_Invoker.Invoke_DownloadFile(const __Instance: IInterface; const __Message: IROMessage; const __Transport: IROTransport; out __oResponseOptions: TROResponseOptions);
var
  l_FileName: string;
  l_StartPos: Integer;
  l_BlockSize: Integer;
  lResult: Binary;
  __lObjectDisposer: TROObjectDisposer;
  __lintf: FileServiceLib_Intf.IFileService;
begin
  CheckRoles(__Instance, GetDefaultServiceRoles());
  lResult := nil;
  try
    if not Supports(__Instance, IFileService, __lintf) then begin
      raise EIntfCastError.Create('Critical error in TFileService_Invoker.Invoke_DownloadFile: __Instance does not support FileService interface');
    end;

    __Message.Read('FileName', System.TypeInfo(string), l_FileName, [paAsUTF8String]);
    __Message.Read('StartPos', System.TypeInfo(Integer), l_StartPos, []);
    __Message.Read('BlockSize', System.TypeInfo(Integer), l_BlockSize, []);

    lResult := __lintf.DownloadFile(l_FileName, l_StartPos, l_BlockSize);

    __Message.InitializeResponseMessage(__Transport, 'FileServiceLib', 'FileService', 'DownloadFileResponse');
    __Message.Write('Result', System.TypeInfo(Binary), lResult, []);
    __Message.Finalize();
    __Message.UnsetAttributes(__Transport);

  finally
    __lintf := nil;
    __lObjectDisposer := TROObjectDisposer.Create(__Instance);
    try
      __lObjectDisposer.Add(lResult);
    finally
      __lObjectDisposer.Free();
    end;
  end;
end;

procedure TFileService_Invoker.Invoke_RenameFile(const __Instance: IInterface; const __Message: IROMessage; const __Transport: IROTransport; out __oResponseOptions: TROResponseOptions);
var
  l_OldName: string;
  l_NewName: string;
  lResult: Integer;
  __lintf: FileServiceLib_Intf.IFileService;
begin
  CheckRoles(__Instance, GetDefaultServiceRoles());
  try
    if not Supports(__Instance, IFileService, __lintf) then begin
      raise EIntfCastError.Create('Critical error in TFileService_Invoker.Invoke_RenameFile: __Instance does not support FileService interface');
    end;

    __Message.Read('OldName', System.TypeInfo(string), l_OldName, [paAsUTF8String]);
    __Message.Read('NewName', System.TypeInfo(string), l_NewName, [paAsUTF8String]);

    lResult := __lintf.RenameFile(l_OldName, l_NewName);

    __Message.InitializeResponseMessage(__Transport, 'FileServiceLib', 'FileService', 'RenameFileResponse');
    __Message.Write('Result', System.TypeInfo(Integer), lResult, []);
    __Message.Finalize();
    __Message.UnsetAttributes(__Transport);

  finally
    __lintf := nil;
  end;
end;

procedure TFileService_Invoker.Invoke_RemoveFile(const __Instance: IInterface; const __Message: IROMessage; const __Transport: IROTransport; out __oResponseOptions: TROResponseOptions);
var
  l_FileName: string;
  lResult: Integer;
  __lintf: FileServiceLib_Intf.IFileService;
begin
  CheckRoles(__Instance, GetDefaultServiceRoles());
  try
    if not Supports(__Instance, IFileService, __lintf) then begin
      raise EIntfCastError.Create('Critical error in TFileService_Invoker.Invoke_RemoveFile: __Instance does not support FileService interface');
    end;

    __Message.Read('FileName', System.TypeInfo(string), l_FileName, [paAsUTF8String]);

    lResult := __lintf.RemoveFile(l_FileName);

    __Message.InitializeResponseMessage(__Transport, 'FileServiceLib', 'FileService', 'RemoveFileResponse');
    __Message.Write('Result', System.TypeInfo(Integer), lResult, []);
    __Message.Finalize();
    __Message.UnsetAttributes(__Transport);

  finally
    __lintf := nil;
  end;
end;

procedure TFileService_Invoker.Invoke_ServiceValue(const __Instance: IInterface; const __Message: IROMessage; const __Transport: IROTransport; out __oResponseOptions: TROResponseOptions);
var
  l_ValueName: string;
  lResult: Variant;
  __lintf: FileServiceLib_Intf.IFileService;
begin
  CheckRoles(__Instance, GetDefaultServiceRoles());
  try
    if not Supports(__Instance, IFileService, __lintf) then begin
      raise EIntfCastError.Create('Critical error in TFileService_Invoker.Invoke_ServiceValue: __Instance does not support FileService interface');
    end;

    __Message.Read('ValueName', System.TypeInfo(string), l_ValueName, [paAsUTF8String]);

    lResult := __lintf.ServiceValue(l_ValueName);

    __Message.InitializeResponseMessage(__Transport, 'FileServiceLib', 'FileService', 'ServiceValueResponse');
    __Message.Write('Result', System.TypeInfo(Variant), lResult, []);
    __Message.Finalize();
    __Message.UnsetAttributes(__Transport);

  finally
    __lintf := nil;
  end;
end;

initialization
finalization
end.

