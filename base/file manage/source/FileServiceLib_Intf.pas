unit FileServiceLib_Intf;

// ----------------------------------------------------------------------
//  This file was automatically generated by Remoting SDK from a
//  RODL file downloaded from a server or associated with this project.
//
//  Do not modify this file manually, or your changes will be lost when
//  it is regenerated the next time you update your RODL.
// ----------------------------------------------------------------------

{$I RemObjects.inc}

interface

uses
  {$IFDEF DELPHIXE2UP}System.SysUtils{$ELSE}SysUtils{$ENDIF},
  {$IFDEF DELPHIXE2UP}System.Classes{$ELSE}Classes{$ENDIF},
  {$IFDEF DELPHIXE2UP}System.TypInfo{$ELSE}TypInfo{$ENDIF},
  uROEncoding,
  uROUri,
  uROProxy,
  uROExceptions,
  uROXMLIntf,
  uROClasses,
  uROTypes,
  uROClientIntf,
  uROAsync,
  uROEventReceiver;

const LibraryUID: String = '{74472DB4-8985-4F9C-868D-124ECED11F7C}';
const DefaultNamespace: String = 'FileServiceLib';
const TargetNamespace: String = 'FileServiceLib';
const IFileService_IID: TGUID = '{77CD540B-3C42-4F1E-ACDD-A9164A759F89}';
type
  { Forward declarations }
  IFileService = interface;
  IFileService_Async = interface;
  IFileService_AsyncEx = interface;
  FileInfo = class;
  FileInfoCollection = class;
  FileArray = class;
  FileArrayEnumerator = class;
  CoFileService = class;
  CoFileService_Async = class;
  CoFileService_AsyncEx = class;
  TFileService_Proxy = class;
  TFileService_AsyncProxy = class;
  TFileService_AsyncProxyEx = class;

  FileInfo = class(TROComplexType)
  private
    fName: string;
    fSize: Integer;
    fTime: Integer;
    fAttr: Integer;
    fMD5: string;
  protected
    procedure FreeInternalProperties; override;
  public
    procedure Assign(aSource: TPersistent); override;
    procedure ReadComplex(aSerializer: TObject); override;
    procedure WriteComplex(aSerializer: TObject); override;
  published
    property Name: string read fName write fName;
    property Size: Integer read fSize write fSize;
    property Time: Integer read fTime write fTime;
    property Attr: Integer read fAttr write fAttr;
    property MD5: string read fMD5 write fMD5;
  end;

  FileInfoCollection = class(TROCollection)
  protected
    constructor Create(aItemClass: TCollectionItemClass); overload;
    function GetItems(aIndex: Integer): FileInfo;
    procedure SetItems(aIndex: Integer; const Value: FileInfo);
  public
    constructor Create; overload;
    function Add: FileInfo; reintroduce;
    procedure LoadFromArray(anArray: FileArray);
    procedure SaveToArray(anArray: FileArray);
    property Items[Index: Integer]: FileInfo read GetItems write SetItems; default;
  end;

  FileArray_FileInfo = array of FileInfo;

  FileArray = class(TROArray)
  private
    fCount: Integer;
    fItems: FileArray_FileInfo;
  protected
    procedure Grow; virtual;
    function GetItems(aIndex: Integer): FileInfo;
    procedure SetItems(aIndex: Integer; Value: FileInfo);
    function GetCount: Integer; override;
    procedure IntResize(anElementCount: Integer; AllocItems: Boolean); override;
  public
    class function GetItemType: PTypeInfo; override;
    class function GetItemClass: System.TClass; override;
    class function GetItemSize: Integer; override;
    function GetItemRef(aIndex: Integer): Pointer; override;
    procedure SetItemRef(aIndex: Integer; Ref: Pointer); override;
    procedure Clear; override;
    procedure Delete(aIndex: Integer); override;
    procedure Assign(aSource: TPersistent); override;
    procedure ReadComplex(aSerializer: TObject); override;
    procedure WriteComplex(aSerializer: TObject); override;
    function Add(Value: FileInfo): Integer; overload;
    function Add: FileInfo; overload;
    function GetEnumerator: FileArrayEnumerator;
    property Count: Integer read GetCount;
    property Items[Index: Integer]: FileInfo read GetItems write SetItems; default;
    property InnerArray: FileArray_FileInfo read fItems;
  end;

  FileArrayEnumerator = class(TObject)
  private
    fArray: FileArray;
    fCurrentIndex: Integer;
    function GetCurrent: FileInfo;
  public
    constructor Create(anArray: FileArray);
    function MoveNext: Boolean;
    property Current: FileInfo read GetCurrent;
  end;

  IFileService = interface(IROService)
  ['{77CD540B-3C42-4F1E-ACDD-A9164A759F89}']
    function FindPath(const Path: string): FileArray;
    function FileAttr(const FileName: string): FileInfo;
    function UploadFile(const FileName: string; const FileSize: Integer; const StartPos: Integer; const Block: Binary): Integer;
    function DownloadFile(const FileName: string; const StartPos: Integer; const BlockSize: Integer): Binary;
    function RenameFile(const OldName: string; const NewName: string): Integer;
    function RemoveFile(const FileName: string): Integer;
    function ServiceValue(const ValueName: string): Variant;
  end;

  IFileService_Async = interface(IROAsyncInterface)
  ['{83EA32A4-16FE-47FE-8DA3-BD9448979647}']
    procedure Invoke_FindPath(const Path: string);
    procedure Invoke_FileAttr(const FileName: string);
    procedure Invoke_UploadFile(const FileName: string; const FileSize: Integer; const StartPos: Integer; const Block: Binary);
    procedure Invoke_DownloadFile(const FileName: string; const StartPos: Integer; const BlockSize: Integer);
    procedure Invoke_RenameFile(const OldName: string; const NewName: string);
    procedure Invoke_RemoveFile(const FileName: string);
    procedure Invoke_ServiceValue(const ValueName: string);
    function Retrieve_FindPath: FileArray;
    function Retrieve_FileAttr: FileInfo;
    function Retrieve_UploadFile: Integer;
    function Retrieve_DownloadFile: Binary;
    function Retrieve_RenameFile: Integer;
    function Retrieve_RemoveFile: Integer;
    function Retrieve_ServiceValue: Variant;
  end;

  IFileService_AsyncEx = interface(IROAsyncInterfaceEx)
  ['{1C95ADFC-CB4B-4177-A5F2-A771B07FC281}']
    function BeginFindPath(const Path: string; const aCallback: TROAsyncCallback; const aUserData: Pointer = nil): IROAsyncRequest;
    function BeginFileAttr(const FileName: string; const aCallback: TROAsyncCallback; const aUserData: Pointer = nil): IROAsyncRequest;
    function BeginUploadFile(const FileName: string; const FileSize: Integer; const StartPos: Integer; const Block: Binary; const aCallback: TROAsyncCallback; const aUserData: Pointer = nil): IROAsyncRequest;
    function BeginDownloadFile(const FileName: string; const StartPos: Integer; const BlockSize: Integer; const aCallback: TROAsyncCallback; const aUserData: Pointer = nil): IROAsyncRequest;
    function BeginRenameFile(const OldName: string; const NewName: string; const aCallback: TROAsyncCallback; const aUserData: Pointer = nil): IROAsyncRequest;
    function BeginRemoveFile(const FileName: string; const aCallback: TROAsyncCallback; const aUserData: Pointer = nil): IROAsyncRequest;
    function BeginServiceValue(const ValueName: string; const aCallback: TROAsyncCallback; const aUserData: Pointer = nil): IROAsyncRequest;
    function EndFindPath(const aRequest: IROAsyncRequest): FileArray;
    function EndFileAttr(const aRequest: IROAsyncRequest): FileInfo;
    function EndUploadFile(const aRequest: IROAsyncRequest): Integer;
    function EndDownloadFile(const aRequest: IROAsyncRequest): Binary;
    function EndRenameFile(const aRequest: IROAsyncRequest): Integer;
    function EndRemoveFile(const aRequest: IROAsyncRequest): Integer;
    function EndServiceValue(const aRequest: IROAsyncRequest): Variant;
  end;

  CoFileService = class(System.TObject)
  public
    class function Create(const aMessage: IROMessage; aTransportChannel: IROTransportChannel): IFileService; overload;
    class function Create(const aUri: TROUri; aDefaultNamespaces: String = ''): IFileService; overload;
    class function Create(const aUrl: String; aDefaultNamespaces: String = ''): IFileService; overload;
  end;

  CoFileService_Async = class(System.TObject)
  public
    class function Create(const aMessage: IROMessage; aTransportChannel: IROTransportChannel): IFileService_Async; overload;
    class function Create(const aUri: TROUri; aDefaultNamespaces: String = ''): IFileService_Async; overload;
    class function Create(const aUrl: String; aDefaultNamespaces: String = ''): IFileService_Async; overload;
  end;

  CoFileService_AsyncEx = class(System.TObject)
  public
    class function Create(const aMessage: IROMessage; aTransportChannel: IROTransportChannel): IFileService_AsyncEx; overload;
    class function Create(const aUri: TROUri; aDefaultNamespaces: String = ''): IFileService_AsyncEx; overload;
    class function Create(const aUrl: String; aDefaultNamespaces: String = ''): IFileService_AsyncEx; overload;
  end;

  TFileService_Proxy = class(TROProxy, IFileService)
  protected
    function __GetInterfaceName: String; override;
    function FindPath(const Path: string): FileArray;
    function FileAttr(const FileName: string): FileInfo;
    function UploadFile(const FileName: string; const FileSize: Integer; const StartPos: Integer; const Block: Binary): Integer;
    function DownloadFile(const FileName: string; const StartPos: Integer; const BlockSize: Integer): Binary;
    function RenameFile(const OldName: string; const NewName: string): Integer;
    function RemoveFile(const FileName: string): Integer;
    function ServiceValue(const ValueName: string): Variant;
  end;

  TFileService_AsyncProxy = class(TROAsyncProxy, IFileService_Async)
  protected
    function __GetInterfaceName: String; override;
    procedure Invoke_FindPath(const Path: string);
    procedure Invoke_FileAttr(const FileName: string);
    procedure Invoke_UploadFile(const FileName: string; const FileSize: Integer; const StartPos: Integer; const Block: Binary);
    procedure Invoke_DownloadFile(const FileName: string; const StartPos: Integer; const BlockSize: Integer);
    procedure Invoke_RenameFile(const OldName: string; const NewName: string);
    procedure Invoke_RemoveFile(const FileName: string);
    procedure Invoke_ServiceValue(const ValueName: string);
    function Retrieve_FindPath: FileArray;
    function Retrieve_FileAttr: FileInfo;
    function Retrieve_UploadFile: Integer;
    function Retrieve_DownloadFile: Binary;
    function Retrieve_RenameFile: Integer;
    function Retrieve_RemoveFile: Integer;
    function Retrieve_ServiceValue: Variant;
  end;

  TFileService_AsyncProxyEx = class(TROAsyncProxyEx, IFileService_AsyncEx)
  protected
    function __GetInterfaceName: String; override;
    function BeginFindPath(const Path: string; const aCallback: TROAsyncCallback; const aUserData: Pointer = nil): IROAsyncRequest;
    function BeginFileAttr(const FileName: string; const aCallback: TROAsyncCallback; const aUserData: Pointer = nil): IROAsyncRequest;
    function BeginUploadFile(const FileName: string; const FileSize: Integer; const StartPos: Integer; const Block: Binary; const aCallback: TROAsyncCallback; const aUserData: Pointer = nil): IROAsyncRequest;
    function BeginDownloadFile(const FileName: string; const StartPos: Integer; const BlockSize: Integer; const aCallback: TROAsyncCallback; const aUserData: Pointer = nil): IROAsyncRequest;
    function BeginRenameFile(const OldName: string; const NewName: string; const aCallback: TROAsyncCallback; const aUserData: Pointer = nil): IROAsyncRequest;
    function BeginRemoveFile(const FileName: string; const aCallback: TROAsyncCallback; const aUserData: Pointer = nil): IROAsyncRequest;
    function BeginServiceValue(const ValueName: string; const aCallback: TROAsyncCallback; const aUserData: Pointer = nil): IROAsyncRequest;
    function EndFindPath(const aRequest: IROAsyncRequest): FileArray;
    function EndFileAttr(const aRequest: IROAsyncRequest): FileInfo;
    function EndUploadFile(const aRequest: IROAsyncRequest): Integer;
    function EndDownloadFile(const aRequest: IROAsyncRequest): Binary;
    function EndRenameFile(const aRequest: IROAsyncRequest): Integer;
    function EndRemoveFile(const aRequest: IROAsyncRequest): Integer;
    function EndServiceValue(const aRequest: IROAsyncRequest): Variant;
  end;

function DefaultNamespaces: String;
implementation

uses
  uROSerializer,
  uROClient,
  uROTransportChannel,
  uRORes;

function DefaultNamespaces: String;
var
  lres: String;
begin
  lres := DefaultNamespace;
  result := lres;
  exit;
end;

type
  { Forward declarations }
  TMyTransportChannel = class;

  TMyTransportChannel = class(TROTransportChannel)
  end;

procedure FileInfo.FreeInternalProperties;
begin
end;

procedure FileInfo.Assign(aSource: TPersistent);
var
  lSource: FileInfo;
begin
  inherited Assign(aSource);
  if aSource.InheritsFrom(FileInfo) then begin
    lSource := FileInfo(aSource);

    Self.Name := lSource.Name;
    Self.Size := lSource.Size;
    Self.Time := lSource.Time;
    Self.Attr := lSource.Attr;
    Self.MD5 := lSource.MD5;
  end;
end;

procedure FileInfo.ReadComplex(aSerializer: TObject);
var
  __Serializer: TROSerializer;
  l_Attr: Integer;
  l_MD5: string;
  l_Name: string;
  l_Size: Integer;
  l_Time: Integer;
begin
  __Serializer := TROSerializer(aSerializer);
  if __Serializer.RecordStrictOrder then begin
    l_Name := Self.Name;
    try
      __Serializer.ReadLegacyString('Name', l_Name, [paAsUTF8String]);
    except
      on E: Exception do begin
        uROClasses.RaiseError('Exception "%s" with message "%s" happens during reading field "%s".', [E.ClassName(), E.Message, 'Name']);
      end;
    end;
    Self.Name := l_Name;
    l_Size := Self.Size;
    try
      __Serializer.ReadInteger('Size', otSLong, l_Size);
    except
      on E: Exception do begin
        uROClasses.RaiseError('Exception "%s" with message "%s" happens during reading field "%s".', [E.ClassName(), E.Message, 'Size']);
      end;
    end;
    Self.Size := l_Size;
    l_Time := Self.Time;
    try
      __Serializer.ReadInteger('Time', otSLong, l_Time);
    except
      on E: Exception do begin
        uROClasses.RaiseError('Exception "%s" with message "%s" happens during reading field "%s".', [E.ClassName(), E.Message, 'Time']);
      end;
    end;
    Self.Time := l_Time;
    l_Attr := Self.Attr;
    try
      __Serializer.ReadInteger('Attr', otSLong, l_Attr);
    except
      on E: Exception do begin
        uROClasses.RaiseError('Exception "%s" with message "%s" happens during reading field "%s".', [E.ClassName(), E.Message, 'Attr']);
      end;
    end;
    Self.Attr := l_Attr;
    l_MD5 := Self.MD5;
    try
      __Serializer.ReadLegacyString('MD5', l_MD5, [paAsUTF8String]);
    except
      on E: Exception do begin
        uROClasses.RaiseError('Exception "%s" with message "%s" happens during reading field "%s".', [E.ClassName(), E.Message, 'MD5']);
      end;
    end;
    Self.MD5 := l_MD5;
  end
  else begin
    l_Attr := Self.Attr;
    try
      __Serializer.ReadInteger('Attr', otSLong, l_Attr);
    except
      on E: Exception do begin
        uROClasses.RaiseError('Exception "%s" with message "%s" happens during reading field "%s".', [E.ClassName(), E.Message, 'Attr']);
      end;
    end;
    Self.Attr := l_Attr;
    l_MD5 := Self.MD5;
    try
      __Serializer.ReadLegacyString('MD5', l_MD5, [paAsUTF8String]);
    except
      on E: Exception do begin
        uROClasses.RaiseError('Exception "%s" with message "%s" happens during reading field "%s".', [E.ClassName(), E.Message, 'MD5']);
      end;
    end;
    Self.MD5 := l_MD5;
    l_Name := Self.Name;
    try
      __Serializer.ReadLegacyString('Name', l_Name, [paAsUTF8String]);
    except
      on E: Exception do begin
        uROClasses.RaiseError('Exception "%s" with message "%s" happens during reading field "%s".', [E.ClassName(), E.Message, 'Name']);
      end;
    end;
    Self.Name := l_Name;
    l_Size := Self.Size;
    try
      __Serializer.ReadInteger('Size', otSLong, l_Size);
    except
      on E: Exception do begin
        uROClasses.RaiseError('Exception "%s" with message "%s" happens during reading field "%s".', [E.ClassName(), E.Message, 'Size']);
      end;
    end;
    Self.Size := l_Size;
    l_Time := Self.Time;
    try
      __Serializer.ReadInteger('Time', otSLong, l_Time);
    except
      on E: Exception do begin
        uROClasses.RaiseError('Exception "%s" with message "%s" happens during reading field "%s".', [E.ClassName(), E.Message, 'Time']);
      end;
    end;
    Self.Time := l_Time;
  end;
end;

procedure FileInfo.WriteComplex(aSerializer: TObject);
var
  __Serializer: TROSerializer;
  l_Attr: Integer;
  l_MD5: string;
  l_Name: string;
  l_Size: Integer;
  l_Time: Integer;
begin
  __Serializer := TROSerializer(aSerializer);
  if __Serializer.RecordStrictOrder then begin
    __Serializer.ChangeClass(FileInfo);
    l_Name := Self.Name;
    __Serializer.WriteLegacyString('Name', l_Name, [paAsUTF8String]);
    l_Size := Self.Size;
    __Serializer.WriteInteger('Size', otSLong, l_Size);
    l_Time := Self.Time;
    __Serializer.WriteInteger('Time', otSLong, l_Time);
    l_Attr := Self.Attr;
    __Serializer.WriteInteger('Attr', otSLong, l_Attr);
    l_MD5 := Self.MD5;
    __Serializer.WriteLegacyString('MD5', l_MD5, [paAsUTF8String]);
  end
  else begin
    l_Attr := Self.Attr;
    __Serializer.WriteInteger('Attr', otSLong, l_Attr);
    l_MD5 := Self.MD5;
    __Serializer.WriteLegacyString('MD5', l_MD5, [paAsUTF8String]);
    l_Name := Self.Name;
    __Serializer.WriteLegacyString('Name', l_Name, [paAsUTF8String]);
    l_Size := Self.Size;
    __Serializer.WriteInteger('Size', otSLong, l_Size);
    l_Time := Self.Time;
    __Serializer.WriteInteger('Time', otSLong, l_Time);
  end;
end;

constructor FileInfoCollection.Create(aItemClass: TCollectionItemClass);
begin
  inherited Create(aItemClass);
end;

function FileInfoCollection.GetItems(aIndex: Integer): FileInfo;
begin
  result := FileInfo(inherited Items[aIndex]);
  exit;
end;

procedure FileInfoCollection.SetItems(aIndex: Integer; const Value: FileInfo);
var
  lvalue: FileInfo;
begin
  lvalue := FileInfo(inherited Items[aIndex]);
  lvalue.Assign(Value);
end;

constructor FileInfoCollection.Create;
begin
  inherited Create(FileInfo);
end;

function FileInfoCollection.Add: FileInfo;
begin
  result := FileInfo(inherited Add());
  exit;
end;

procedure FileInfoCollection.LoadFromArray(anArray: FileArray);
var
  i: Integer;
begin
  Self.Clear();
  for i := 0 to anArray.Count - 1 do
    if assigned(anArray[i]) then begin
      anArray[i].Clone().Collection := Self;
    end;
end;

procedure FileInfoCollection.SaveToArray(anArray: FileArray);
var
  i: Integer;
begin
  anArray.Clear();
  for i := 0 to Self.Count - 1 do
    if assigned(Self.Items[i]) then begin
      anArray.Add(FileInfo(Self.Items[i].Clone()));
    end
    else begin
      anArray.Add(nil);
    end;
end;

procedure FileArray.Grow;
var
  lDelta: Integer;
  lCapacity: Integer;
begin
  lCapacity := System.Length(fItems);
  if lCapacity > 64 then begin
    lDelta := lCapacity div 4;
  end
  else begin
    if lCapacity > 8 then begin
      lDelta := 16;
    end
    else begin
      lDelta := 4;
    end;
  end;
  System.SetLength(fItems, lCapacity + lDelta);
end;

function FileArray.GetItems(aIndex: Integer): FileInfo;
begin
  if (aIndex < 0) or (aIndex >= fCount) then begin
    uROClasses.RaiseError(err_ArrayIndexOutOfBounds, [aIndex]);
  end;
  result := fItems[aIndex];
  exit;
end;

procedure FileArray.SetItems(aIndex: Integer; Value: FileInfo);
begin
  if (aIndex < 0) or (aIndex >= fCount) then begin
    uROClasses.RaiseError(err_ArrayIndexOutOfBounds, [aIndex]);
  end;
  if fItems[aIndex] <> Value then begin
    fItems[aIndex].Free();
    fItems[aIndex] := Value;
  end;
end;

function FileArray.GetCount: Integer;
begin
  result := fCount;
  exit;
end;

procedure FileArray.IntResize(anElementCount: Integer; AllocItems: Boolean);
var
  i: Integer;
begin
  if fCount = anElementCount then begin
    exit;
  end;
  for i := fCount - 1 downto anElementCount do
    fItems[i].Free();
  System.SetLength(fItems, anElementCount);
  for i := fCount to anElementCount - 1 do
    if AllocItems then begin
      fItems[i] := FileInfo.Create();
    end
    else begin
      fItems[i] := nil;
    end;
  fCount := anElementCount;
end;

class function FileArray.GetItemType: PTypeInfo;
begin
  result := System.TypeInfo(FileInfo);
  exit;
end;

class function FileArray.GetItemClass: System.TClass;
begin
  result := FileInfo;
  exit;
end;

class function FileArray.GetItemSize: Integer;
begin
  result := sizeOf(FileInfo);
  exit;
end;

function FileArray.GetItemRef(aIndex: Integer): Pointer;
begin
  if (aIndex < 0) or (aIndex >= fCount) then begin
    uROClasses.RaiseError(err_ArrayIndexOutOfBounds, [aIndex]);
  end;
  result := fItems[aIndex];
  exit;
end;

procedure FileArray.SetItemRef(aIndex: Integer; Ref: Pointer);
begin
  if (aIndex < 0) or (aIndex >= fCount) then begin
    uROClasses.RaiseError(err_ArrayIndexOutOfBounds, [aIndex]);
  end;
  if Ref <> fItems[aIndex] then begin
    if assigned(fItems[aIndex]) then begin
      fItems[aIndex].Free();
    end;
    fItems[aIndex] := FileInfo(Ref);
  end;
end;

procedure FileArray.Clear;
var
  i: Integer;
begin
  for i := 0 to fCount - 1 do
    fItems[i].Free();
  System.SetLength(fItems, 0);
  fCount := 0;
end;

procedure FileArray.Delete(aIndex: Integer);
var
  i: Integer;
begin
  if aIndex >= fCount then begin
    uROClasses.RaiseError(err_InvalidIndex, [aIndex]);
  end;

  fItems[aIndex].Free();

  if aIndex < (fCount - 1) then begin
    for i := aIndex to fCount - 2 do
      fItems[i] := fItems[i + 1];
  end;
  System.SetLength(fItems, fCount - 1);
  fCount := fCount - 1;
end;

procedure FileArray.Assign(aSource: TPersistent);
var
  lSource: FileArray;
  i: Integer;
  lItem: FileInfo;
begin
  if aSource.InheritsFrom(FileArray) then begin
    lSource := FileArray(aSource);
    Self.Clear();

    for i := 0 to lSource.Count - 1 do
      if assigned(lSource.Items[i]) then begin
        lItem := FileInfo(lSource.Items[i].Clone());
        Self.Add(lItem);
      end
      else begin
        Self.Add(nil);
      end;
  end
  else begin
    inherited Assign(aSource);
  end;
end;

procedure FileArray.ReadComplex(aSerializer: TObject);
var
  __Serializer: TROSerializer;
  lval: FileInfo;
  i: Integer;
begin
  __Serializer := TROSerializer(aSerializer);
  for i := 0 to fCount - 1 do begin
    __Serializer.ReadStruct(__Serializer.GetArrayElementName(GetItemType(), GetItemRef(i)), FileInfo, lval, i);
    Self.Items[i] := lval;
  end;
end;

procedure FileArray.WriteComplex(aSerializer: TObject);
var
  __Serializer: TROSerializer;
  i: Integer;
begin
  __Serializer := TROSerializer(aSerializer);
  __Serializer.ChangeClass(FileArray);
  for i := 0 to fCount - 1 do begin
    __Serializer.WriteStruct(__Serializer.GetArrayElementName(GetItemType(), GetItemRef(i)), fItems[i], FileInfo, i);
  end;
end;

function FileArray.Add(Value: FileInfo): Integer;
var
  lResult: Integer;
begin
  lResult := fCount;
  if System.Length(fItems) = lResult then begin
    Self.Grow();
  end;
  fItems[lResult] := Value;
  fCount := fCount + 1;
  result := lResult;
  exit;
end;

function FileArray.Add: FileInfo;
var
  lres: FileInfo;
begin
  lres := FileInfo.Create();
  Self.Add(lres);
  result := lres;
  exit;
end;

function FileArray.GetEnumerator: FileArrayEnumerator;
begin
  result := FileArrayEnumerator.Create(Self);
  exit;
end;

function FileArrayEnumerator.GetCurrent: FileInfo;
begin
  result := fArray.Items[fCurrentIndex];
  exit;
end;

constructor FileArrayEnumerator.Create(anArray: FileArray);
begin
  inherited Create();
  fArray := anArray;
  fCurrentIndex := -1;
end;

function FileArrayEnumerator.MoveNext: Boolean;
var
  lResult: Boolean;
begin
  lResult := fCurrentIndex < (fArray.Count - 1);
  if lResult then begin
    fCurrentIndex := fCurrentIndex + 1;
  end;
  result := lResult;
  exit;
end;

class function CoFileService.Create(const aMessage: IROMessage; aTransportChannel: IROTransportChannel): IFileService;
begin
  result := TFileService_Proxy.Create(aMessage, aTransportChannel);
  exit;
end;

class function CoFileService.Create(const aUri: TROUri; aDefaultNamespaces: String = ''): IFileService;
begin
  result := TFileService_Proxy.Create(aUri, aDefaultNamespaces);
  exit;
end;

class function CoFileService.Create(const aUrl: String; aDefaultNamespaces: String = ''): IFileService;
begin
  result := TFileService_Proxy.Create(aUrl, aDefaultNamespaces);
  exit;
end;

class function CoFileService_Async.Create(const aMessage: IROMessage; aTransportChannel: IROTransportChannel): IFileService_Async;
begin
  result := TFileService_AsyncProxy.Create(aMessage, aTransportChannel);
  exit;
end;

class function CoFileService_Async.Create(const aUri: TROUri; aDefaultNamespaces: String = ''): IFileService_Async;
begin
  result := TFileService_AsyncProxy.Create(aUri, aDefaultNamespaces);
  exit;
end;

class function CoFileService_Async.Create(const aUrl: String; aDefaultNamespaces: String = ''): IFileService_Async;
begin
  result := TFileService_AsyncProxy.Create(aUrl, aDefaultNamespaces);
  exit;
end;

class function CoFileService_AsyncEx.Create(const aMessage: IROMessage; aTransportChannel: IROTransportChannel): IFileService_AsyncEx;
begin
  result := TFileService_AsyncProxyEx.Create(aMessage, aTransportChannel);
  exit;
end;

class function CoFileService_AsyncEx.Create(const aUri: TROUri; aDefaultNamespaces: String = ''): IFileService_AsyncEx;
begin
  result := TFileService_AsyncProxyEx.Create(aUri, aDefaultNamespaces);
  exit;
end;

class function CoFileService_AsyncEx.Create(const aUrl: String; aDefaultNamespaces: String = ''): IFileService_AsyncEx;
begin
  result := TFileService_AsyncProxyEx.Create(aUrl, aDefaultNamespaces);
  exit;
end;

function TFileService_Proxy.__GetInterfaceName: String;
begin
  result := 'FileService';
  exit;
end;

function TFileService_Proxy.FindPath(const Path: string): FileArray;
var
  lMessage: IROMessage;
  lTransportChannel: IROTransportChannel;
  lResult: FileArray;
begin
  lMessage := __GetMessage();
  lMessage.SetAutoGeneratedNamespaces(DefaultNamespaces());
  lTransportChannel := __TransportChannel;
  try
    lResult := nil;
    lMessage.InitializeRequestMessage(lTransportChannel, 'FileServiceLib', __InterfaceName, 'FindPath');
    lMessage.Write('Path', System.TypeInfo(string), Path, [paAsUTF8String]);
    lMessage.Finalize();

    lTransportChannel.Dispatch(lMessage);

    lMessage.Read('Result', System.TypeInfo(FileArray), lResult, []);
  finally
    lMessage.UnsetAttributes(lTransportChannel);
    lMessage.FreeStream();
    lMessage := nil;
    lTransportChannel := nil;
  end;
  result := lResult;
  exit;
end;

function TFileService_Proxy.FileAttr(const FileName: string): FileInfo;
var
  lMessage: IROMessage;
  lTransportChannel: IROTransportChannel;
  lResult: FileInfo;
begin
  lMessage := __GetMessage();
  lMessage.SetAutoGeneratedNamespaces(DefaultNamespaces());
  lTransportChannel := __TransportChannel;
  try
    lResult := nil;
    lMessage.InitializeRequestMessage(lTransportChannel, 'FileServiceLib', __InterfaceName, 'FileAttr');
    lMessage.Write('FileName', System.TypeInfo(string), FileName, [paAsUTF8String]);
    lMessage.Finalize();

    lTransportChannel.Dispatch(lMessage);

    lMessage.Read('Result', System.TypeInfo(FileInfo), lResult, []);
  finally
    lMessage.UnsetAttributes(lTransportChannel);
    lMessage.FreeStream();
    lMessage := nil;
    lTransportChannel := nil;
  end;
  result := lResult;
  exit;
end;

function TFileService_Proxy.UploadFile(const FileName: string; const FileSize: Integer; const StartPos: Integer; const Block: Binary): Integer;
var
  lMessage: IROMessage;
  lTransportChannel: IROTransportChannel;
  lResult: Integer;
begin
  lMessage := __GetMessage();
  lMessage.SetAutoGeneratedNamespaces(DefaultNamespaces());
  lTransportChannel := __TransportChannel;
  try
    lMessage.InitializeRequestMessage(lTransportChannel, 'FileServiceLib', __InterfaceName, 'UploadFile');
    lMessage.Write('FileName', System.TypeInfo(string), FileName, [paAsUTF8String]);
    lMessage.Write('FileSize', System.TypeInfo(Integer), FileSize, []);
    lMessage.Write('StartPos', System.TypeInfo(Integer), StartPos, []);
    lMessage.Write('Block', System.TypeInfo(Binary), Block, []);
    lMessage.Finalize();

    lTransportChannel.Dispatch(lMessage);

    lMessage.Read('Result', System.TypeInfo(Integer), lResult, []);
  finally
    lMessage.UnsetAttributes(lTransportChannel);
    lMessage.FreeStream();
    lMessage := nil;
    lTransportChannel := nil;
  end;
  result := lResult;
  exit;
end;

function TFileService_Proxy.DownloadFile(const FileName: string; const StartPos: Integer; const BlockSize: Integer): Binary;
var
  lMessage: IROMessage;
  lTransportChannel: IROTransportChannel;
  lResult: Binary;
begin
  lMessage := __GetMessage();
  lMessage.SetAutoGeneratedNamespaces(DefaultNamespaces());
  lTransportChannel := __TransportChannel;
  try
    lResult := nil;
    lMessage.InitializeRequestMessage(lTransportChannel, 'FileServiceLib', __InterfaceName, 'DownloadFile');
    lMessage.Write('FileName', System.TypeInfo(string), FileName, [paAsUTF8String]);
    lMessage.Write('StartPos', System.TypeInfo(Integer), StartPos, []);
    lMessage.Write('BlockSize', System.TypeInfo(Integer), BlockSize, []);
    lMessage.Finalize();

    lTransportChannel.Dispatch(lMessage);

    lMessage.Read('Result', System.TypeInfo(Binary), lResult, []);
  finally
    lMessage.UnsetAttributes(lTransportChannel);
    lMessage.FreeStream();
    lMessage := nil;
    lTransportChannel := nil;
  end;
  result := lResult;
  exit;
end;

function TFileService_Proxy.RenameFile(const OldName: string; const NewName: string): Integer;
var
  lMessage: IROMessage;
  lTransportChannel: IROTransportChannel;
  lResult: Integer;
begin
  lMessage := __GetMessage();
  lMessage.SetAutoGeneratedNamespaces(DefaultNamespaces());
  lTransportChannel := __TransportChannel;
  try
    lMessage.InitializeRequestMessage(lTransportChannel, 'FileServiceLib', __InterfaceName, 'RenameFile');
    lMessage.Write('OldName', System.TypeInfo(string), OldName, [paAsUTF8String]);
    lMessage.Write('NewName', System.TypeInfo(string), NewName, [paAsUTF8String]);
    lMessage.Finalize();

    lTransportChannel.Dispatch(lMessage);

    lMessage.Read('Result', System.TypeInfo(Integer), lResult, []);
  finally
    lMessage.UnsetAttributes(lTransportChannel);
    lMessage.FreeStream();
    lMessage := nil;
    lTransportChannel := nil;
  end;
  result := lResult;
  exit;
end;

function TFileService_Proxy.RemoveFile(const FileName: string): Integer;
var
  lMessage: IROMessage;
  lTransportChannel: IROTransportChannel;
  lResult: Integer;
begin
  lMessage := __GetMessage();
  lMessage.SetAutoGeneratedNamespaces(DefaultNamespaces());
  lTransportChannel := __TransportChannel;
  try
    lMessage.InitializeRequestMessage(lTransportChannel, 'FileServiceLib', __InterfaceName, 'RemoveFile');
    lMessage.Write('FileName', System.TypeInfo(string), FileName, [paAsUTF8String]);
    lMessage.Finalize();

    lTransportChannel.Dispatch(lMessage);

    lMessage.Read('Result', System.TypeInfo(Integer), lResult, []);
  finally
    lMessage.UnsetAttributes(lTransportChannel);
    lMessage.FreeStream();
    lMessage := nil;
    lTransportChannel := nil;
  end;
  result := lResult;
  exit;
end;

function TFileService_Proxy.ServiceValue(const ValueName: string): Variant;
var
  lMessage: IROMessage;
  lTransportChannel: IROTransportChannel;
  lResult: Variant;
begin
  lMessage := __GetMessage();
  lMessage.SetAutoGeneratedNamespaces(DefaultNamespaces());
  lTransportChannel := __TransportChannel;
  try
    lMessage.InitializeRequestMessage(lTransportChannel, 'FileServiceLib', __InterfaceName, 'ServiceValue');
    lMessage.Write('ValueName', System.TypeInfo(string), ValueName, [paAsUTF8String]);
    lMessage.Finalize();

    lTransportChannel.Dispatch(lMessage);

    lMessage.Read('Result', System.TypeInfo(Variant), lResult, []);
  finally
    lMessage.UnsetAttributes(lTransportChannel);
    lMessage.FreeStream();
    lMessage := nil;
    lTransportChannel := nil;
  end;
  result := lResult;
  exit;
end;

function TFileService_AsyncProxy.__GetInterfaceName: String;
begin
  result := 'FileService';
  exit;
end;

procedure TFileService_AsyncProxy.Invoke_FindPath(const Path: string);
var
  lMessage: IROMessage;
  lTransportChannel: IROTransportChannel;
begin
  lMessage := __GetMessage();
  lMessage.SetAutoGeneratedNamespaces(DefaultNamespaces());
  lTransportChannel := __TransportChannel;
  try
    __AssertProxyNotBusy('FindPath');

    lMessage.InitializeRequestMessage(lTransportChannel, 'FileServiceLib', __InterfaceName, 'FindPath');
    lMessage.Write('Path', System.TypeInfo(string), Path, [paAsUTF8String]);
    __DispatchAsyncRequest('FindPath', lMessage);
  finally
    lMessage.UnsetAttributes(lTransportChannel);
    lMessage := nil;
    lTransportChannel := nil;
  end;
end;

procedure TFileService_AsyncProxy.Invoke_FileAttr(const FileName: string);
var
  lMessage: IROMessage;
  lTransportChannel: IROTransportChannel;
begin
  lMessage := __GetMessage();
  lMessage.SetAutoGeneratedNamespaces(DefaultNamespaces());
  lTransportChannel := __TransportChannel;
  try
    __AssertProxyNotBusy('FileAttr');

    lMessage.InitializeRequestMessage(lTransportChannel, 'FileServiceLib', __InterfaceName, 'FileAttr');
    lMessage.Write('FileName', System.TypeInfo(string), FileName, [paAsUTF8String]);
    __DispatchAsyncRequest('FileAttr', lMessage);
  finally
    lMessage.UnsetAttributes(lTransportChannel);
    lMessage := nil;
    lTransportChannel := nil;
  end;
end;

procedure TFileService_AsyncProxy.Invoke_UploadFile(const FileName: string; const FileSize: Integer; const StartPos: Integer; const Block: Binary);
var
  lMessage: IROMessage;
  lTransportChannel: IROTransportChannel;
begin
  lMessage := __GetMessage();
  lMessage.SetAutoGeneratedNamespaces(DefaultNamespaces());
  lTransportChannel := __TransportChannel;
  try
    __AssertProxyNotBusy('UploadFile');

    lMessage.InitializeRequestMessage(lTransportChannel, 'FileServiceLib', __InterfaceName, 'UploadFile');
    lMessage.Write('FileName', System.TypeInfo(string), FileName, [paAsUTF8String]);
    lMessage.Write('FileSize', System.TypeInfo(Integer), FileSize, []);
    lMessage.Write('StartPos', System.TypeInfo(Integer), StartPos, []);
    lMessage.Write('Block', System.TypeInfo(Binary), Block, []);
    __DispatchAsyncRequest('UploadFile', lMessage);
  finally
    lMessage.UnsetAttributes(lTransportChannel);
    lMessage := nil;
    lTransportChannel := nil;
  end;
end;

procedure TFileService_AsyncProxy.Invoke_DownloadFile(const FileName: string; const StartPos: Integer; const BlockSize: Integer);
var
  lMessage: IROMessage;
  lTransportChannel: IROTransportChannel;
begin
  lMessage := __GetMessage();
  lMessage.SetAutoGeneratedNamespaces(DefaultNamespaces());
  lTransportChannel := __TransportChannel;
  try
    __AssertProxyNotBusy('DownloadFile');

    lMessage.InitializeRequestMessage(lTransportChannel, 'FileServiceLib', __InterfaceName, 'DownloadFile');
    lMessage.Write('FileName', System.TypeInfo(string), FileName, [paAsUTF8String]);
    lMessage.Write('StartPos', System.TypeInfo(Integer), StartPos, []);
    lMessage.Write('BlockSize', System.TypeInfo(Integer), BlockSize, []);
    __DispatchAsyncRequest('DownloadFile', lMessage);
  finally
    lMessage.UnsetAttributes(lTransportChannel);
    lMessage := nil;
    lTransportChannel := nil;
  end;
end;

procedure TFileService_AsyncProxy.Invoke_RenameFile(const OldName: string; const NewName: string);
var
  lMessage: IROMessage;
  lTransportChannel: IROTransportChannel;
begin
  lMessage := __GetMessage();
  lMessage.SetAutoGeneratedNamespaces(DefaultNamespaces());
  lTransportChannel := __TransportChannel;
  try
    __AssertProxyNotBusy('RenameFile');

    lMessage.InitializeRequestMessage(lTransportChannel, 'FileServiceLib', __InterfaceName, 'RenameFile');
    lMessage.Write('OldName', System.TypeInfo(string), OldName, [paAsUTF8String]);
    lMessage.Write('NewName', System.TypeInfo(string), NewName, [paAsUTF8String]);
    __DispatchAsyncRequest('RenameFile', lMessage);
  finally
    lMessage.UnsetAttributes(lTransportChannel);
    lMessage := nil;
    lTransportChannel := nil;
  end;
end;

procedure TFileService_AsyncProxy.Invoke_RemoveFile(const FileName: string);
var
  lMessage: IROMessage;
  lTransportChannel: IROTransportChannel;
begin
  lMessage := __GetMessage();
  lMessage.SetAutoGeneratedNamespaces(DefaultNamespaces());
  lTransportChannel := __TransportChannel;
  try
    __AssertProxyNotBusy('RemoveFile');

    lMessage.InitializeRequestMessage(lTransportChannel, 'FileServiceLib', __InterfaceName, 'RemoveFile');
    lMessage.Write('FileName', System.TypeInfo(string), FileName, [paAsUTF8String]);
    __DispatchAsyncRequest('RemoveFile', lMessage);
  finally
    lMessage.UnsetAttributes(lTransportChannel);
    lMessage := nil;
    lTransportChannel := nil;
  end;
end;

procedure TFileService_AsyncProxy.Invoke_ServiceValue(const ValueName: string);
var
  lMessage: IROMessage;
  lTransportChannel: IROTransportChannel;
begin
  lMessage := __GetMessage();
  lMessage.SetAutoGeneratedNamespaces(DefaultNamespaces());
  lTransportChannel := __TransportChannel;
  try
    __AssertProxyNotBusy('ServiceValue');

    lMessage.InitializeRequestMessage(lTransportChannel, 'FileServiceLib', __InterfaceName, 'ServiceValue');
    lMessage.Write('ValueName', System.TypeInfo(string), ValueName, [paAsUTF8String]);
    __DispatchAsyncRequest('ServiceValue', lMessage);
  finally
    lMessage.UnsetAttributes(lTransportChannel);
    lMessage := nil;
    lTransportChannel := nil;
  end;
end;

function TFileService_AsyncProxy.Retrieve_FindPath: FileArray;
var
  __response: TStream;
  tc: TMyTransportChannel;
  lRetry: Boolean;
  lMessage: IROMessage;
  lTransportChannel: IROTransportChannel;
  lFreeStream: Boolean;
  lResult: FileArray;
begin
  lMessage := __GetMessage();
  lMessage.SetAutoGeneratedNamespaces(DefaultNamespaces());
  lTransportChannel := __TransportChannel;
  lFreeStream := false;
  try
    lResult := nil;
    __response := __RetrieveAsyncResponse('FindPath');
    try
      try
        try
          lMessage.ReadFromStream(__response, lFreeStream);
        except
          on E: Exception do begin
            lFreeStream := true;
            raise;
          end;
        end;

        lMessage.Read('Result', System.TypeInfo(FileArray), lResult, []);
      except
        on E: EROSessionNotFound do begin
          tc := TMyTransportChannel(lTransportChannel.GetTransportObject());
          lRetry := false;
          tc.DoLoginNeeded(lMessage, E, lRetry);
          if not lRetry then begin
            raise;
          end;
        end;
        on E: Exception do begin
          raise;
        end;
      end;
    finally
      if lFreeStream then begin
        __response.Free();
      end;
    end;
  finally
    lMessage := nil;
    lTransportChannel := nil;
  end;
  result := lResult;
  exit;
end;

function TFileService_AsyncProxy.Retrieve_FileAttr: FileInfo;
var
  __response: TStream;
  tc: TMyTransportChannel;
  lRetry: Boolean;
  lMessage: IROMessage;
  lTransportChannel: IROTransportChannel;
  lFreeStream: Boolean;
  lResult: FileInfo;
begin
  lMessage := __GetMessage();
  lMessage.SetAutoGeneratedNamespaces(DefaultNamespaces());
  lTransportChannel := __TransportChannel;
  lFreeStream := false;
  try
    lResult := nil;
    __response := __RetrieveAsyncResponse('FileAttr');
    try
      try
        try
          lMessage.ReadFromStream(__response, lFreeStream);
        except
          on E: Exception do begin
            lFreeStream := true;
            raise;
          end;
        end;

        lMessage.Read('Result', System.TypeInfo(FileInfo), lResult, []);
      except
        on E: EROSessionNotFound do begin
          tc := TMyTransportChannel(lTransportChannel.GetTransportObject());
          lRetry := false;
          tc.DoLoginNeeded(lMessage, E, lRetry);
          if not lRetry then begin
            raise;
          end;
        end;
        on E: Exception do begin
          raise;
        end;
      end;
    finally
      if lFreeStream then begin
        __response.Free();
      end;
    end;
  finally
    lMessage := nil;
    lTransportChannel := nil;
  end;
  result := lResult;
  exit;
end;

function TFileService_AsyncProxy.Retrieve_UploadFile: Integer;
var
  __response: TStream;
  tc: TMyTransportChannel;
  lRetry: Boolean;
  lMessage: IROMessage;
  lTransportChannel: IROTransportChannel;
  lFreeStream: Boolean;
  lResult: Integer;
begin
  lMessage := __GetMessage();
  lMessage.SetAutoGeneratedNamespaces(DefaultNamespaces());
  lTransportChannel := __TransportChannel;
  lFreeStream := false;
  try
    __response := __RetrieveAsyncResponse('UploadFile');
    try
      try
        try
          lMessage.ReadFromStream(__response, lFreeStream);
        except
          on E: Exception do begin
            lFreeStream := true;
            raise;
          end;
        end;

        lMessage.Read('Result', System.TypeInfo(Integer), lResult, []);
      except
        on E: EROSessionNotFound do begin
          tc := TMyTransportChannel(lTransportChannel.GetTransportObject());
          lRetry := false;
          tc.DoLoginNeeded(lMessage, E, lRetry);
          if not lRetry then begin
            raise;
          end;
        end;
        on E: Exception do begin
          raise;
        end;
      end;
    finally
      if lFreeStream then begin
        __response.Free();
      end;
    end;
  finally
    lMessage := nil;
    lTransportChannel := nil;
  end;
  result := lResult;
  exit;
end;

function TFileService_AsyncProxy.Retrieve_DownloadFile: Binary;
var
  __response: TStream;
  tc: TMyTransportChannel;
  lRetry: Boolean;
  lMessage: IROMessage;
  lTransportChannel: IROTransportChannel;
  lFreeStream: Boolean;
  lResult: Binary;
begin
  lMessage := __GetMessage();
  lMessage.SetAutoGeneratedNamespaces(DefaultNamespaces());
  lTransportChannel := __TransportChannel;
  lFreeStream := false;
  try
    lResult := nil;
    __response := __RetrieveAsyncResponse('DownloadFile');
    try
      try
        try
          lMessage.ReadFromStream(__response, lFreeStream);
        except
          on E: Exception do begin
            lFreeStream := true;
            raise;
          end;
        end;

        lMessage.Read('Result', System.TypeInfo(Binary), lResult, []);
      except
        on E: EROSessionNotFound do begin
          tc := TMyTransportChannel(lTransportChannel.GetTransportObject());
          lRetry := false;
          tc.DoLoginNeeded(lMessage, E, lRetry);
          if not lRetry then begin
            raise;
          end;
        end;
        on E: Exception do begin
          raise;
        end;
      end;
    finally
      if lFreeStream then begin
        __response.Free();
      end;
    end;
  finally
    lMessage := nil;
    lTransportChannel := nil;
  end;
  result := lResult;
  exit;
end;

function TFileService_AsyncProxy.Retrieve_RenameFile: Integer;
var
  __response: TStream;
  tc: TMyTransportChannel;
  lRetry: Boolean;
  lMessage: IROMessage;
  lTransportChannel: IROTransportChannel;
  lFreeStream: Boolean;
  lResult: Integer;
begin
  lMessage := __GetMessage();
  lMessage.SetAutoGeneratedNamespaces(DefaultNamespaces());
  lTransportChannel := __TransportChannel;
  lFreeStream := false;
  try
    __response := __RetrieveAsyncResponse('RenameFile');
    try
      try
        try
          lMessage.ReadFromStream(__response, lFreeStream);
        except
          on E: Exception do begin
            lFreeStream := true;
            raise;
          end;
        end;

        lMessage.Read('Result', System.TypeInfo(Integer), lResult, []);
      except
        on E: EROSessionNotFound do begin
          tc := TMyTransportChannel(lTransportChannel.GetTransportObject());
          lRetry := false;
          tc.DoLoginNeeded(lMessage, E, lRetry);
          if not lRetry then begin
            raise;
          end;
        end;
        on E: Exception do begin
          raise;
        end;
      end;
    finally
      if lFreeStream then begin
        __response.Free();
      end;
    end;
  finally
    lMessage := nil;
    lTransportChannel := nil;
  end;
  result := lResult;
  exit;
end;

function TFileService_AsyncProxy.Retrieve_RemoveFile: Integer;
var
  __response: TStream;
  tc: TMyTransportChannel;
  lRetry: Boolean;
  lMessage: IROMessage;
  lTransportChannel: IROTransportChannel;
  lFreeStream: Boolean;
  lResult: Integer;
begin
  lMessage := __GetMessage();
  lMessage.SetAutoGeneratedNamespaces(DefaultNamespaces());
  lTransportChannel := __TransportChannel;
  lFreeStream := false;
  try
    __response := __RetrieveAsyncResponse('RemoveFile');
    try
      try
        try
          lMessage.ReadFromStream(__response, lFreeStream);
        except
          on E: Exception do begin
            lFreeStream := true;
            raise;
          end;
        end;

        lMessage.Read('Result', System.TypeInfo(Integer), lResult, []);
      except
        on E: EROSessionNotFound do begin
          tc := TMyTransportChannel(lTransportChannel.GetTransportObject());
          lRetry := false;
          tc.DoLoginNeeded(lMessage, E, lRetry);
          if not lRetry then begin
            raise;
          end;
        end;
        on E: Exception do begin
          raise;
        end;
      end;
    finally
      if lFreeStream then begin
        __response.Free();
      end;
    end;
  finally
    lMessage := nil;
    lTransportChannel := nil;
  end;
  result := lResult;
  exit;
end;

function TFileService_AsyncProxy.Retrieve_ServiceValue: Variant;
var
  __response: TStream;
  tc: TMyTransportChannel;
  lRetry: Boolean;
  lMessage: IROMessage;
  lTransportChannel: IROTransportChannel;
  lFreeStream: Boolean;
  lResult: Variant;
begin
  lMessage := __GetMessage();
  lMessage.SetAutoGeneratedNamespaces(DefaultNamespaces());
  lTransportChannel := __TransportChannel;
  lFreeStream := false;
  try
    __response := __RetrieveAsyncResponse('ServiceValue');
    try
      try
        try
          lMessage.ReadFromStream(__response, lFreeStream);
        except
          on E: Exception do begin
            lFreeStream := true;
            raise;
          end;
        end;

        lMessage.Read('Result', System.TypeInfo(Variant), lResult, []);
      except
        on E: EROSessionNotFound do begin
          tc := TMyTransportChannel(lTransportChannel.GetTransportObject());
          lRetry := false;
          tc.DoLoginNeeded(lMessage, E, lRetry);
          if not lRetry then begin
            raise;
          end;
        end;
        on E: Exception do begin
          raise;
        end;
      end;
    finally
      if lFreeStream then begin
        __response.Free();
      end;
    end;
  finally
    lMessage := nil;
    lTransportChannel := nil;
  end;
  result := lResult;
  exit;
end;

function TFileService_AsyncProxyEx.__GetInterfaceName: String;
begin
  result := 'FileService';
  exit;
end;

function TFileService_AsyncProxyEx.BeginFindPath(const Path: string; const aCallback: TROAsyncCallback; const aUserData: Pointer = nil): IROAsyncRequest;
var
  lMessage: IROMessage;
  lTransportChannel: IROTransportChannel;
  lResult: IROAsyncRequest;
begin
  lMessage := __GetMessage();
  lMessage.SetAutoGeneratedNamespaces(DefaultNamespaces());
  lTransportChannel := __TransportChannel;
  try
    lMessage.InitializeRequestMessage(lTransportChannel, 'FileServiceLib', __InterfaceName, 'FindPath');
    lMessage.Write('Path', System.TypeInfo(string), Path, [paAsUTF8String]);
    lResult := __DispatchAsyncRequest(lMessage, aCallback, aUserData);
  finally
    lMessage := nil;
    lTransportChannel := nil;
  end;
  result := lResult;
  exit;
end;

function TFileService_AsyncProxyEx.BeginFileAttr(const FileName: string; const aCallback: TROAsyncCallback; const aUserData: Pointer = nil): IROAsyncRequest;
var
  lMessage: IROMessage;
  lTransportChannel: IROTransportChannel;
  lResult: IROAsyncRequest;
begin
  lMessage := __GetMessage();
  lMessage.SetAutoGeneratedNamespaces(DefaultNamespaces());
  lTransportChannel := __TransportChannel;
  try
    lMessage.InitializeRequestMessage(lTransportChannel, 'FileServiceLib', __InterfaceName, 'FileAttr');
    lMessage.Write('FileName', System.TypeInfo(string), FileName, [paAsUTF8String]);
    lResult := __DispatchAsyncRequest(lMessage, aCallback, aUserData);
  finally
    lMessage := nil;
    lTransportChannel := nil;
  end;
  result := lResult;
  exit;
end;

function TFileService_AsyncProxyEx.BeginUploadFile(const FileName: string; const FileSize: Integer; const StartPos: Integer; const Block: Binary; const aCallback: TROAsyncCallback; const aUserData: Pointer = nil): IROAsyncRequest;
var
  lMessage: IROMessage;
  lTransportChannel: IROTransportChannel;
  lResult: IROAsyncRequest;
begin
  lMessage := __GetMessage();
  lMessage.SetAutoGeneratedNamespaces(DefaultNamespaces());
  lTransportChannel := __TransportChannel;
  try
    lMessage.InitializeRequestMessage(lTransportChannel, 'FileServiceLib', __InterfaceName, 'UploadFile');
    lMessage.Write('FileName', System.TypeInfo(string), FileName, [paAsUTF8String]);
    lMessage.Write('FileSize', System.TypeInfo(Integer), FileSize, []);
    lMessage.Write('StartPos', System.TypeInfo(Integer), StartPos, []);
    lMessage.Write('Block', System.TypeInfo(Binary), Block, []);
    lResult := __DispatchAsyncRequest(lMessage, aCallback, aUserData);
  finally
    lMessage := nil;
    lTransportChannel := nil;
  end;
  result := lResult;
  exit;
end;

function TFileService_AsyncProxyEx.BeginDownloadFile(const FileName: string; const StartPos: Integer; const BlockSize: Integer; const aCallback: TROAsyncCallback; const aUserData: Pointer = nil): IROAsyncRequest;
var
  lMessage: IROMessage;
  lTransportChannel: IROTransportChannel;
  lResult: IROAsyncRequest;
begin
  lMessage := __GetMessage();
  lMessage.SetAutoGeneratedNamespaces(DefaultNamespaces());
  lTransportChannel := __TransportChannel;
  try
    lMessage.InitializeRequestMessage(lTransportChannel, 'FileServiceLib', __InterfaceName, 'DownloadFile');
    lMessage.Write('FileName', System.TypeInfo(string), FileName, [paAsUTF8String]);
    lMessage.Write('StartPos', System.TypeInfo(Integer), StartPos, []);
    lMessage.Write('BlockSize', System.TypeInfo(Integer), BlockSize, []);
    lResult := __DispatchAsyncRequest(lMessage, aCallback, aUserData);
  finally
    lMessage := nil;
    lTransportChannel := nil;
  end;
  result := lResult;
  exit;
end;

function TFileService_AsyncProxyEx.BeginRenameFile(const OldName: string; const NewName: string; const aCallback: TROAsyncCallback; const aUserData: Pointer = nil): IROAsyncRequest;
var
  lMessage: IROMessage;
  lTransportChannel: IROTransportChannel;
  lResult: IROAsyncRequest;
begin
  lMessage := __GetMessage();
  lMessage.SetAutoGeneratedNamespaces(DefaultNamespaces());
  lTransportChannel := __TransportChannel;
  try
    lMessage.InitializeRequestMessage(lTransportChannel, 'FileServiceLib', __InterfaceName, 'RenameFile');
    lMessage.Write('OldName', System.TypeInfo(string), OldName, [paAsUTF8String]);
    lMessage.Write('NewName', System.TypeInfo(string), NewName, [paAsUTF8String]);
    lResult := __DispatchAsyncRequest(lMessage, aCallback, aUserData);
  finally
    lMessage := nil;
    lTransportChannel := nil;
  end;
  result := lResult;
  exit;
end;

function TFileService_AsyncProxyEx.BeginRemoveFile(const FileName: string; const aCallback: TROAsyncCallback; const aUserData: Pointer = nil): IROAsyncRequest;
var
  lMessage: IROMessage;
  lTransportChannel: IROTransportChannel;
  lResult: IROAsyncRequest;
begin
  lMessage := __GetMessage();
  lMessage.SetAutoGeneratedNamespaces(DefaultNamespaces());
  lTransportChannel := __TransportChannel;
  try
    lMessage.InitializeRequestMessage(lTransportChannel, 'FileServiceLib', __InterfaceName, 'RemoveFile');
    lMessage.Write('FileName', System.TypeInfo(string), FileName, [paAsUTF8String]);
    lResult := __DispatchAsyncRequest(lMessage, aCallback, aUserData);
  finally
    lMessage := nil;
    lTransportChannel := nil;
  end;
  result := lResult;
  exit;
end;

function TFileService_AsyncProxyEx.BeginServiceValue(const ValueName: string; const aCallback: TROAsyncCallback; const aUserData: Pointer = nil): IROAsyncRequest;
var
  lMessage: IROMessage;
  lTransportChannel: IROTransportChannel;
  lResult: IROAsyncRequest;
begin
  lMessage := __GetMessage();
  lMessage.SetAutoGeneratedNamespaces(DefaultNamespaces());
  lTransportChannel := __TransportChannel;
  try
    lMessage.InitializeRequestMessage(lTransportChannel, 'FileServiceLib', __InterfaceName, 'ServiceValue');
    lMessage.Write('ValueName', System.TypeInfo(string), ValueName, [paAsUTF8String]);
    lResult := __DispatchAsyncRequest(lMessage, aCallback, aUserData);
  finally
    lMessage := nil;
    lTransportChannel := nil;
  end;
  result := lResult;
  exit;
end;

function TFileService_AsyncProxyEx.EndFindPath(const aRequest: IROAsyncRequest): FileArray;
var
  lResult: FileArray;
begin
  lResult := nil;
  aRequest.ReadResponse();
  aRequest.Message.SetAutoGeneratedNamespaces(DefaultNamespaces());
  aRequest.Message.Read('Result', System.TypeInfo(FileArray), lResult, []);
  result := lResult;
  exit;
end;

function TFileService_AsyncProxyEx.EndFileAttr(const aRequest: IROAsyncRequest): FileInfo;
var
  lResult: FileInfo;
begin
  lResult := nil;
  aRequest.ReadResponse();
  aRequest.Message.SetAutoGeneratedNamespaces(DefaultNamespaces());
  aRequest.Message.Read('Result', System.TypeInfo(FileInfo), lResult, []);
  result := lResult;
  exit;
end;

function TFileService_AsyncProxyEx.EndUploadFile(const aRequest: IROAsyncRequest): Integer;
var
  lResult: Integer;
begin
  aRequest.ReadResponse();
  aRequest.Message.SetAutoGeneratedNamespaces(DefaultNamespaces());
  aRequest.Message.Read('Result', System.TypeInfo(Integer), lResult, []);
  result := lResult;
  exit;
end;

function TFileService_AsyncProxyEx.EndDownloadFile(const aRequest: IROAsyncRequest): Binary;
var
  lResult: Binary;
begin
  lResult := nil;
  aRequest.ReadResponse();
  aRequest.Message.SetAutoGeneratedNamespaces(DefaultNamespaces());
  aRequest.Message.Read('Result', System.TypeInfo(Binary), lResult, []);
  result := lResult;
  exit;
end;

function TFileService_AsyncProxyEx.EndRenameFile(const aRequest: IROAsyncRequest): Integer;
var
  lResult: Integer;
begin
  aRequest.ReadResponse();
  aRequest.Message.SetAutoGeneratedNamespaces(DefaultNamespaces());
  aRequest.Message.Read('Result', System.TypeInfo(Integer), lResult, []);
  result := lResult;
  exit;
end;

function TFileService_AsyncProxyEx.EndRemoveFile(const aRequest: IROAsyncRequest): Integer;
var
  lResult: Integer;
begin
  aRequest.ReadResponse();
  aRequest.Message.SetAutoGeneratedNamespaces(DefaultNamespaces());
  aRequest.Message.Read('Result', System.TypeInfo(Integer), lResult, []);
  result := lResult;
  exit;
end;

function TFileService_AsyncProxyEx.EndServiceValue(const aRequest: IROAsyncRequest): Variant;
var
  lResult: Variant;
begin
  aRequest.ReadResponse();
  aRequest.Message.SetAutoGeneratedNamespaces(DefaultNamespaces());
  aRequest.Message.Read('Result', System.TypeInfo(Variant), lResult, []);
  result := lResult;
  exit;
end;

initialization
  RegisterROClass(FileInfo, DefaultNamespace);
  RegisterROClass(FileArray, DefaultNamespace);
  RegisterProxyClass(IFileService_IID, TFileService_Proxy);
finalization
  UnregisterROClass(FileInfo, DefaultNamespace);
  UnregisterROClass(FileArray, DefaultNamespace);
  UnregisterProxyClass(IFileService_IID);
end.

